#
# Shared OTP environment setup
#
# Assume this is being sourced by bash, so BASH_SOURCE[0] is this file,
# BASH_SOURCE[1] is the file that sourced this one, etc...
#
# A few environment variables are recognized and/or required:
#
#   ERL_TOP SHOULD be set to the top of an Erlang/OTP source tree. If not
#   present, it is set to the current working directory.
#
#   otp_name MAY be set to the name of the directory under otp.install.base
#   where the release will be installed.
#   If not set it is calculated by otp.local.name
#   Whether preset or not, it is unset after this file is sourced!
#
#   config_opts MAY be set to the options to be passed to ./configure
#   and its ilk.
#   If not set, an appropriate one is used.
#   Whether preset or not, it is unset after this file is sourced!
#
#   The following environment variables are unset if present:
#       MAKEFLAGS
#   
#   The following environment variables are set to basic values if not set:
#       CC CXX CFLAGS CXXFLAGS LANG LDFLAGS
#   
#   The following environment variables are unset during reset_lenv()
#   cleanup IFF they were set by this file:
#       ERL_TOP CC CXX CFLAGS CXXFLAGS LANG LDFLAGS
#
#   env_reset_unalias, env_reset_unset, env_reset_unsetf, if set, will be
#   parameters to 'unalias', 'unset', and 'unset -f', respectively during
#   reset_lenv() cleanup.
#

[[ -z "$(type -t kerl_deactivate)" ]] || kerl_deactivate

if [[ -z "$ERL_TOP" ]]
then
    ERL_TOP="$(pwd)"
    env_reset_unset+=' ERL_TOP'
fi
for d in bin bootstrap erts lib system
do
    if [[ ! -d "$ERL_TOP/$d" ]]
    then
        echo    "$sname error: '$ERL_TOP' doesn't look like an OTP build directory" >&2
        echo    "    * directory '$ERL_TOP/$d' is missing" >&2
        unset   d
        return  2
    fi
done
unset   d MAKEFLAGS
export  ERL_TOP

if [[ "$PATH" != "$ERL_TOP/bin":* ]]
then
    export  PATH="$ERL_TOP/bin:$PATH"
    hash    -r
fi

kerl_deactivate()
{
    if [[ -n "$ERL_TOP" && "$PATH" == "$ERL_TOP/bin":* ]]
    then
        export  PATH="${PATH#${ERL_TOP}/bin:}"
        hash    -r
    fi
    unset   -f kerl_deactivate
}

. "$LOCAL_ENV_DIR/os.type"
. "$LOCAL_ENV_DIR/otp.install.base"
. "$LOCAL_ENV_DIR/otp.local.name"
. "$LOCAL_ENV_DIR/otp.source.version"
env_local_unset+=' os_type'
env_local_unset+=' otp_install_base otp_name otp_source_base'
env_reset_unset+=' otp_release otp_vsn_major otp_vsn_minor'

OTP_LOCAL_NAME="$otp_name"
OTP_LOCAL_INST="$otp_install_base/$otp_name"
env_reset_unset+=' OTP_LOCAL_INST OTP_LOCAL_NAME'
export  OTP_LOCAL_INST OTP_LOCAL_NAME

arch_flags='-m64 -march=core2 -mcx16'
arch_flags='-m64 -march=native -mcx16'
env_local_unset+=' arch_flags'
case "$os_type" in
    darwin )
        osx_ver="$(/usr/bin/sw_vers -productVersion | /usr/bin/cut -d. -f1,2)"
        env_local_unset+=' osx_ver'
        arch_flags+=" -arch x86_64 -mmacosx-version-min=$osx_ver"
        ;;
    linux )
        ;;
    freebsd )
        ;;
    * )
        ;;
esac
if [[ -z "$CC" ]]
then
    case "$os_type" in
        darwin )
            cands='icc /usr/bin/cc gcc cc'
            ;;
        linux )
            cands='icc gcc cc'
            ;;
        *bsd )
            cands='icc clang37 cc gcc'
            ;;
        * )
            cands='icc clang cc gcc'
            ;;
    esac
    for c in $cands
    do
        CC="$(which $c)"
        [[ -z "$CC" ]] || break
    done
    unset c cands
    env_reset_unset+=' CC'
fi
if [[ -z "$CXX" ]]
then
    if [[ "${CC##*/}" == icc || "${CC##*/}" == clang* ]]
    then
        CXX="$CC"
    else
        case "$os_type" in
            darwin )
                cands="/usr/bin/c++ g++ $CC"
                ;;
            linux )
                cands="g++ gcc c++ $CC"
                ;;
            * )
                cands="c++ g++ $CC"
                ;;
        esac
        for c in $cands
        do
            CXX="$(which $c)"
            [[ -z "$CXX" ]] || break
        done
        unset c cands
    fi
    env_reset_unset+=' CXX'
fi
if [[ -z "$CFLAGS" ]]
then
    CFLAGS="$arch_flags -O3"
    if [[ $otp_vsn_major -lt 17 ]]
    then
        CFLAGS+=' -Wno-deprecated-declarations'
        CFLAGS+=' -Wno-empty-body'
        CFLAGS+=' -Wno-implicit-function-declaration'
        CFLAGS+=' -Wno-parentheses-equality'
        CFLAGS+=' -Wno-pointer-sign'
        CFLAGS+=' -Wno-tentative-definition-incomplete-type'
        CFLAGS+=' -Wno-unused-function'
        CFLAGS+=' -Wno-unused-value'
        CFLAGS+=' -Wno-unused-variable'
    fi
    env_reset_unset+=' CFLAGS'
fi
if [[ -z "$CXXFLAGS" ]]
then
    CXXFLAGS="$CFLAGS"
    env_reset_unset+=' CXXFLAGS'
fi
if [[ -z "$LANG" ]]
then
    LANG='C'
    env_reset_unset+=' LANG'
fi
if [[ -z "$LDFLAGS" ]]
then
    LDFLAGS="$arch_flags -O4"
    env_reset_unset+=' LDFLAGS'
fi
export  CC CXX CFLAGS CXXFLAGS LANG LDFLAGS

if [[ -z "$config_opts" ]]
then
    config_opts="--prefix $otp_install_base/$otp_name --with-ssl"
    case "$os_type" in
        darwin )
            config_opts+=' --enable-darwin-64bit --with-cocoa'

            # Basho OTP-16+ has legal ODBC code, but ODBC is depracated after OS X 10.8
            if [[ "${osx_ver#*.}" -gt 8 || $otp_vsn_major -lt 16 ]]
            then
                config_opts+=' --without-odbc'
            fi

            # HiPE is not to be trusted on 64-bit OS X prior to ???
            if [[ $otp_vsn_major -lt 18 ]]
            then
                config_opts+=' --disable-hipe'
            fi

            # Prior to OTP-17 the java docs won't build
            [[ $otp_vsn_major -ge 17 ]] || config_opts+=' --without-javac'
            ;;
        * )
            config_opts+=' --enable-64bit'
            # config_opts+=' --without-odbc'
            ;;
    esac

    # OTP-15- 64-bit can't use wx, even 64-bit wx
    [[ $otp_vsn_major -ge 16 ]] || config_opts+=' --without-wx'

    # gs is deprecated as of OTP-17
    [[ $otp_vsn_major -lt 17 ]] || config_opts+=' --without-gs'

    # Yay for dirty schedulers!
    [[ $otp_vsn_major -lt 17 ]] || config_opts+=' --enable-dirty-schedulers'

    env_local_unset+=' config_opts'
fi

build_log="$ERL_TOP/build.$os_type.out.txt"
env_reset_unset+=' build_log'

newer()
{
    echo 'Not implemented!'
}
env_reset_unsetf+=' newer'

run_build()
{
    local mf='-j5'
    cd "$ERL_TOP"
    /bin/date >"$build_log"
    echo "MAKEFLAGS=$mf" "$@" >>"$build_log"
    /usr/bin/tail -f "$build_log" &
    local tp=$!
    MAKEFLAGS="$mf" "$@" >>"$build_log"
    local n=$?
    /bin/date >>"$build_log"
    kill "$tp"
    unset tp mf
    hash -r
    return $n
}
env_reset_unsetf+=' run_build'

if [[ "$otp_vsn_major" -ge 16 ]]
then
    smoke()
    {
        cd "$ERL_TOP"
        $MAKE tests
        cd 'release/tests/test_server'
        TZ='MET' "$ERL_TOP/bin/erl" -s ts install -s ts smoke_test batch -s init stop
        cd "$ERL_TOP"
        if [[ -z "$SSH_CLIENT" && -z "$SSH_TTY" && "$(uname -s)" == [Dd]arwin ]]
        then
            open 'release/tests/test_server/index.html'
        else
            echo open "'$ERL_TOP/release/tests/test_server/index.html'"
        fi
    }
else
    smoke()
    {
        cd "$ERL_TOP"
        $MAKE tests
        cd 'release/tests/test_server'
        local scr='ts:install(), ts:run(['
        scr+='emulator, kernel, stdlib, erl_interface, os_mon, ic, system'
        scr+='], [batch]), halt().'
        TZ='MET' "$ERL_TOP/bin/erl" -noshell -eval "$scr"
        unset scr
        cd "$ERL_TOP"
        if [[ -z "$SSH_CLIENT" && -z "$SSH_TTY" && "$(uname -s)" == [Dd]arwin ]]
        then
            open 'release/tests/test_server/index.html'
        else
            echo open "'$ERL_TOP/release/tests/test_server/index.html'"
        fi
    }
fi
env_reset_unsetf+=' smoke'

install_local_otp()
{
    cd "$ERL_TOP"
    $MAKE install
    if [[ -d "$OTP_LOCAL_INST" && ! -f "$OTP_LOCAL_INST/activate" ]]
    then
        /bin/ln -s "$LOCAL_ENV_DIR/otp.activate" "$OTP_LOCAL_INST/activate"
    fi
}
env_reset_unsetf+=' install_local_otp'

alias blog="m '$build_log'"
alias clean="cd '$ERL_TOP' && $MAKE clean && hash -r"
alias config="cd '$ERL_TOP' && ./otp_build configure $config_opts"
#alias inst="cd '$ERL_TOP' && '$LOCAL_ENV_DIR/replace.otp' '$otp_name'"
alias inst='install_local_otp'
alias mkconf="cd '$ERL_TOP' && ./otp_build autoconf"
alias mkdocs="cd '$ERL_TOP' && $MAKE docs install-docs"
alias mkerl="run_build $MAKE"
alias mktest="cd '$ERL_TOP' && $MAKE tests && cd 'release/tests/test_server' && '$ERL_TOP/bin/erl' -s ts install -s init stop && cd '$ERL_TOP'"
alias setup="run_build ./otp_build setup -a $config_opts"
alias vclean="cd '$ERL_TOP' && $GIT clean -fdx -e /env -e /.idea/ -e '*.iml' -e '/*.txt' && hash -r"
alias bdebug="cd '$ERL_TOP/erts/emulator' && $MAKE debug FLAVOR=plain && $MAKE debug FLAVOR=smp"
alias erld="$ERL_TOP/bin/cerl -debug"
env_reset_unalias+='bdebug blog clean config erld inst mkconf mkdocs mkerl mktest setup vclean'

alias sslopts="cd '$ERL_TOP' && /usr/bin/egrep -Rlw '(sslv3|secure_renegotiate|honor_cipher_order|padding_check)' lib/ssl/doc/src lib/ssl/src lib/ssl/test"
env_reset_unalias+=' sslopts'

unset $env_local_unset env_local_unset

s()
{
    ss

    echo '    setup   otp_build setup -a ... >build-log'
    echo '    bdebug  build a debug OTP kernel'
    echo '    erld    run ERL with the debug kernel'
    echo '    smoke   make & run smoke tests'
    echo '    inst    install/replace local installation'
    echo '    vclean  deep clean build'
    echo ''
    echo '    blog    open build-log'
    echo '    clean   cleanup build'
    echo '    config  otp_build configure ...'
    echo '    mkconf  otp_build autoconf'
    echo '    mkdocs  make & install docs'
    echo '    mkerl   make >build-log'
    echo '    mktest  make tests'
    echo '    newer   report whether source tree is newer than istallation'
    echo ''
    echo '    sslopts list files containing target ssl options'
    echo ''
}
env_reset_unsetf+=' s'

# reset_lenv()
# {
#     [[ "$(typeof kerl_deactivate)" == 'undefined' ]] || kerl_deactivate
#
#     if [[ -n "$env_reset_unalias" ]]
#     then
#         unalias $env_reset_unalias 2>/dev/null
#         unset env_reset_unalias
#     fi
#     if [[ -n "$env_reset_unsetf" ]]
#     then
#         unset -f $env_reset_unsetf 2>/dev/null
#         unset env_reset_unsetf
#     fi
#     if [[ -n "$env_reset_unset" ]]
#     then
#         unset $env_reset_unset 2>/dev/null
#         unset env_reset_unset
#     fi
#     unset -f reset_lenv
# }
