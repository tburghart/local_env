#
# Work with Riak CS
#

CS_TOP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
env_reset_unset+=' CS_TOP_DIR'
export CS_TOP_DIR

if [[ -z "$CS_RUNNABLE" ]]
then
    CS_RUNNABLE='false'
    env_reset_unset+=' CS_RUNNABLE'
    export CS_RUNNABLE
fi

kerl_deactivate 2>/dev/null || true

if $CS_RUNNABLE
then
    env_reset_path="$PATH"
    env_reset_unset+=' env_reset_path'
fi
otp_15_base='/opt/basho/otp-15-p1'
otp_16_base='/opt/basho/otp-16-b10'
env_reset_unset+=' otp_15_base otp_16_base'

. "$otp_16_base/activate"

[[ "$(ulimit -n)" -ge 65536 ]] || ulimit -n 65536 2>/dev/null || true

if $CS_RUNNABLE
then
    PATH="$CS_TOP_DIR/stanchion/rel/stanchion/bin:$PATH"
    PATH="$CS_TOP_DIR/riak_ee/rel/riak/bin:$PATH"
    PATH="$CS_TOP_DIR/riak_cs/rel/riak-cs/bin:$PATH"
    export PATH
fi

RIAK_CS_EE_DEPS=true
env_reset_unset+=' RIAK_CS_EE_DEPS'
export RIAK_CS_EE_DEPS

unset DEVNODES CC CPPFLAGS CXX CXXFLAGS LDFLAGS

CFLAGS='-m64 -march=native -mcx16 -O3'
env_reset_unset+=' CFLAGS'
export CFLAGS

if [[ -z "$LANG" ]]
then
    LANG='C'
    env_reset_unset+=' LANG'
    export LANG
fi

update_ee_dev()
{
    local ee_etc="$1/etc"
    local cs_ebin="$2/ebin"
    local dir kv key tmp
    for dir in "$ee_etc" "$cs_ebin"
    do
        if [[ ! -d "$dir" ]]
        then
            echo "update_ee_dev: error: '$dir' is not a directory" >&2
            return 2
        fi
    done
    for kv in \
        'buckets.default.allow_mult = true' \
        'buckets.default.merge_strategy = 2' \
        'cs_version = 20100' \
        'storage_backend = prefix_multi'
    do
        key="${kv%%[ =]*}"
        key="${key//./\\.}"
        if egrep -q "^[[:space:]#]*${key}[[:space:]]*=" "$ee_etc/riak.conf"
        then
            $ESED -i "s/^[[:space:]#]*${key}[[:space:]]*=.*\$/${kv}/" "$ee_etc/riak.conf"
        else
            printf "# For Riak CS\\n${kv}\\n" >> "$ee_etc/riak.conf"
        fi
    done
    if egrep -q '^[[:space:]]*\{[[:space:]]*riak_kv[[:space:]]*,' "$ee_etc/advanced.config"
    then
        if egrep -q \
            '^[[:space:]]*\{[[:space:]]*add_paths[[:space:]]*,[[:space:]]*\["[^"]+/ebin"\]' \
            "$ee_etc/advanced.config"
        then
            $ESED -i \
                "s!^([[:space:]]*\\{[[:space:]]*add_paths[[:space:]]*,[[:space:]]*\\[\")[^\"]+/ebin(\"\\].*)\$!\1${cs_ebin}\2!" \
                "$ee_etc/advanced.config"
        else
            echo "update_ee_dev: error: can't grok '$ee_etc/advanced.config'" >&2
            return 3
        fi
    else
        tmp="$(mktemp /tmp/ac.XXXXXXX)"
        awk -v "cs_ebin=$cs_ebin" 'BEGIN { changed = 0 } {
            if ( NF == 1 && changed == 0 && $1 == "[" ) {
                printf("[\n {riak_kv, [\n  {add_paths, [\"%s\"]}\n ]},\n\n", cs_ebin)
                changed += 1
            } else print }' \
        "$ee_etc/advanced.config" > "$tmp"
        cat "$tmp" > "$ee_etc/advanced.config"
        rm -f "$tmp"
    fi
}
env_reset_unsetf+=' update_ee_dev'

alias update_ee_rel="update_ee_dev $CS_TOP_DIR/riak_ee/rel/riak $CS_TOP_DIR/riak_cs"
env_reset_unalias+=' update_ee_rel'

rt_setup_devrel()
{
    local source="$1"
    local rtroot="${2%/*}"
    local rtvers="${2##*/}"
    local current="$(pwd)"

    printf 'Using OTP: %s %s\n' "$(which erl)" "$(which erlc)"

    echo "builing '$source'" \
    && cd "$source" \
    && $MAKE clean \
    && rm -rf deps dev \
    && $GIT reset HEAD --hard 1>/dev/null 2>&1 \
    && $GIT clean -fd 1>/dev/null 2>&1 \
    && $MAKE devrel \
    && \
    echo "installing '$rtroot/$rtvers'" \
    && cd "$rtroot" \
    && $GIT reset HEAD --hard 1>/dev/null 2>&1 \
    && $GIT clean -fd 1>/dev/null 2>&1 \
    && rm -rf "$rtvers" \
    && mkdir "$rtvers" \
    && cp -pPR "$source/dev" "$rtvers/dev" \
    && printf "$(cd "$source" && $GIT describe --tags)" > "$rtvers/VERSION" \
    && $GIT add --ignore-removal "$rtvers" \
    && $GIT commit -m 'riak_test init' --amend "$rtvers" >/dev/null

    local ret=$?
    cd "$current"
    return $ret
}
rt_setup()
{
    . "$otp_16_base/activate"

    rt_setup_devrel "$CS_TOP_DIR/riak_ee" "$CS_TOP_DIR/rt/riak_ee/current" \
    && \
    rt_setup_devrel "$CS_TOP_DIR/stanchion" "$CS_TOP_DIR/rt/stanchion/current" \
    && \
    rt_setup_devrel "$CS_TOP_DIR/riak_cs" "$CS_TOP_DIR/rt/riak_cs/current"
}
rt_setup_prev()
{
    . "$otp_15_base/activate"

    rt_setup_devrel "$CS_TOP_DIR/riak_ee-1.4" "$CS_TOP_DIR/rt/riak_ee/1.4" \
    && \
    rt_setup_devrel "$CS_TOP_DIR/stanchion-1.5" "$CS_TOP_DIR/rt/stanchion/1.5" \
    && \
    rt_setup_devrel "$CS_TOP_DIR/riak_cs-1.5" "$CS_TOP_DIR/rt/riak_cs/1.5"

    local ret=$?
    . "$otp_16_base/activate"
    return $ret
}
env_reset_unsetf+=' rt_setup_devrel rt_setup rt_setup_prev'

if $CS_RUNNABLE
then
    start()
    {
        local n r
        for n in riak stanchion riak-cs
        do
            $n start
            r=$?
            [[ $r -eq 0 ]] || return $r
            echo $n started.
        done
    }
    stop()
    {
        local n c r=0
        for n in riak-cs stanchion riak
        do
            $n stop
            c=$?
            if [[ $c -ne 0 ]]
            then
                [[ $r -ne 0 ]] || r=$c
                echo $n error: $c
            else
                echo $n stopped.
            fi
        done
        return $r
    }
    env_reset_unsetf+=' start stop'
fi

rt()
{
    local cur="$(pwd)"

    . "$otp_16_base/activate"

    cd "$CS_TOP_DIR/riak_test" \
    && "$CS_TOP_DIR/riak_test/riak_test" -F "$CS_TOP_DIR/rt.config" "$@"
    local ret=$?
    cd "$cur"
    return $ret
}
rtb()
{
    local cur="$(pwd)"

    . "$otp_16_base/activate"

    cd "$CS_TOP_DIR/riak_cs" \
    && $MAKE compile-riak-test compile-client-test \
    && \
    cd "$CS_TOP_DIR/riak_test" \
    && "$CS_TOP_DIR/riak_test/riak_test" -F "$CS_TOP_DIR/rt.config" "$@"
    local ret=$?
    cd "$cur"
    return $ret
}
env_reset_unsetf+=' rt rtb'

alias lt="ls -1 $CS_TOP_DIR/riak_cs/riak_test/tests/*.erl | $ESED 's/^.*\/([^/]+)\.erl$/  -t \1/'"
alias xrt="rm -rf $CS_TOP_DIR/riak_test/log*/* && rt"
alias xrtb="rm -rf $CS_TOP_DIR/riak_test/log*/* && rtb"
alias xrta="rm -rf $CS_TOP_DIR/riak_test/log*/* && rtb -d $CS_TOP_DIR/riak_cs/riak_test/ebin"
env_reset_unalias+=' lt xrt xrtb xrta'

if [[ -f '/usr/local/bin/s3cmd' ]]
then
    alias s3="/usr/local/bin/s3cmd -c $CS_TOP_DIR/s3cmd.cfg"
    env_reset_unalias+=' s3'
fi

alias r15=". $otp_15_base/activate"
alias r16=". $otp_16_base/activate"
env_reset_unalias+=' r15 r16'

env_ss_format='    %15s %s\n'
env_reset_unset+=' env_ss_format'

s()
{
    ss

    echo '    rt_setup_devrel   <source> <rt-dest>  build/install the source package to rt'
    echo '    update_ee_dev     <ee-node> <cs-root>  set up ee node to use cs'
    echo '    update_ee_rel     update the current riak_ee/rel to use current cs'
    echo ''
    echo '    s                 display this list'
    if alias s3 1>/dev/null 2>&1
    then
        echo '    s3                s3cmd'
    fi
    echo ''
    echo '    rt_setup_prev     build/install previous cs/ee/stanchion in rt'
    echo '    rt_setup          build/install current cs/ee/stanchion in rt'
    if $CS_RUNNABLE
    then
        echo ''
        echo '    start             start ee, stanchion, and cs'
        echo '    stop              stop cs, stanchion, and ee'
    fi
    echo ''
    echo '    lt                list cs tests'
    echo '    rt                riak_test'
    echo '    rtb               build tests and run riak_test'
    echo '    xrt               delete test logs and run riak_test'
    echo '    xrtb              delete test logs, build tests, and run riak_test'
    echo '    xrta              delete test logs, build and run all tests'
    echo ''
}
env_reset_unsetf+=' s'

reset_lenv()
{
    [[ "$(typeof kerl_deactivate)" == 'undefined' ]] || kerl_deactivate

    if [[ -n "$env_reset_path" ]]
    then
        PATH="$env_reset_path"
        unset env_reset_path
        export PATH
        hash -r
    fi
    if [[ -n "$env_reset_unalias" ]]
    then
        unalias $env_reset_unalias 2>/dev/null
        unset env_reset_unalias
        alias r15='. /opt/basho/otp-15/activate'
        alias r16='. /opt/basho/otp-16/activate'
    fi
    if [[ -n "$env_reset_unsetf" ]]
    then
        unset -f $env_reset_unsetf 2>/dev/null
        unset env_reset_unsetf
    fi
    if [[ -n "$env_reset_unset" ]]
    then
        unset $env_reset_unset 2>/dev/null
        unset env_reset_unset
    fi
    unset -f reset_lenv
}

unset $env_local_unset env_local_unset
