#!/usr/bin/false 'This file is meant to be sourced'
# shellcheck disable=SC2096 # shebangs can only specify a single parameter
# ========================================================================
# Copyright (c) 1994-2024 T. R. Burghart.
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# ========================================================================
#
# .shrc - Shell startup script for Bourne-ish login shells
#
# Refer to files in https://github.com/tburghart/local_env
#
# Install to $HOME/.shrc, or wherever $ENV points to
#
# Assume that I've chosen to use a relatively modern shell, so I don't
# have to protect against dinosaurs like the system-level files do
#

. "$HOME/etc/shell/sh.interactive"
. "$HOME/etc/shell/sh.terminal"
. "$HOME/etc/shell/sh.aliases"
. "$HOME/etc/shell/sh.lenv"
. "$HOME/etc/shell/sh.git"
#. "$HOME/etc/shell/sh.otp"

return 0





isvar()
{
    if [[ $# -ne 1 ]]
    then
        echo 'usage: isvar <name>' >&2
        return 1
    fi
    case "$(eval echo "\$$1")" in
        \$ | '' )
            if set | grep -q "^$1="
            then
                return 0
            else
                return 1
            fi
            ;;
        * )
            return 0
            ;;
    esac
}


dirpath()
{
    if [[ $# -ne 1 ]]
    then
        echo 'usage: dirpath <filesystem-path>' >&2
        return 1
    fi
    if [[ -d "$1" ]]
    then
        d="$1"
    else
        d="$(dirname "$1")"
    fi
    case "$d" in
        '.' )
            pwd
            ;;
        '..' )
            dirname "$(pwd)"
            ;;
        * )
            (cd "$d" && pwd)
            ;;
    esac
    unset d
}

m()
{
    if [[ $# -eq 0 ]]
    then
        "$MATE"
    else
        for n in "$@"
        do
            "$MATE" -m "$(basename "$(dirpath "$n")") $(basename "$n")" "$n"
        done
        unset n
    fi
}

if [[ -n "$LOCAL_ENV_DIR" && -d "$LOCAL_ENV_DIR/.." ]]
then
    alias le="cd $LOCAL_ENV_DIR/.."
fi

# SSH
alias aws-scp='/usr/bin/scp -p -i /Users/ted/.aws/aws.ssh.1.pem'
alias aws-ssh='/usr/bin/ssh -R 52698:localhost:52698 -i /Users/ted/.aws/aws.ssh.1.pem'
alias chimera='/usr/bin/ssh -R 52698:localhost:52698 -l root chimera'
alias tshome='/usr/bin/ssh -R 52698:localhost:52698 -p 22007 tshome'

# Stuff
alias remake="$MAKE clean && $MAKE"
alias dircp='/bin/pax -rw -pe -X'
alias rtconf="m ~/.riak_test.config"
alias shconf="m ~/.shrc"
alias shrc=". ~/.shrc"
alias e="$MATE"
[[ -z "$BASHO_PRJ_BASE" ]] || alias b="cd $BASHO_PRJ_BASE"
[[ -z "$WDAY_PRJ_BASE" ]] || alias d="cd $WDAY_PRJ_BASE"
[[ -z "$TRB_PRJ_BASE" ]] || alias t="cd $TRB_PRJ_BASE"
[[ -z "$R3R_PRJ_BASE" ]] || alias rr="cd $R3R_PRJ_BASE"

th()
{
    export HISTFILE="$( \
        /bin/ls -1 /tmp/tsh.???????? 2>/dev/null || \
        /usr/bin/mktemp /tmp/tsh.XXXXXXXX )"
    [[ ! -s "$HISTFILE" ]] || history -r "$HISTFILE"
}

# Idea IDE(s)
__shrc_ideajdks="$(/bin/ls -1d \
    ~/Library/Preferences/IdeaIC*/options/jdk.table.xml 2>/dev/null \
    | tail -1)"
if [[ -n "$__shrc_ideajdks" && -f "$__shrc_ideajdks" ]]
then
    alias ideaerls="m $__shrc_ideajdks"
    alias ideadirs="/usr/bin/find ~/prj -type d -name .idea && echo $__shrc_ideajdks"
fi
unset __shrc_ideajdks

# Dates
alias utcs="date '+%s'"
# BSD and GNU versions of 'date' use different options, try both
d2utcs()
{
    date -jf '%a %b %d %T %Z %Y' "$*" '+%s' 2>/dev/null \
    || date "--date=$*" '+%s'
}
utcs2d()
{
    date -jf '%s' "$*" 2>/dev/null \
    || date "--date=@$*"
}

# Scripts
alias newbash='newscr bash'
alias newes='newscr escript'
alias newksh='newscr ksh'
alias newsh='newscr sh'
alias newzsh='newscr zsh'

# Ruby Path to Enlightenment
alias rp="cd $HOME/prj/ruby/koans && ruby path_to_enlightenment.rb"

# git


# Erlang

otp_ga=($(/bin/ls -1 $LOCAL_OTP_DIR | sed -En 's/^otp-([1-9][0-9])-ga$/\1/p' | sort -u | tail -3))
otp_rc="$((${otp_ga##* } + 1))"

exports()
{
    if [[ $# -ne 1 || ! -f "$1" ]]
    then
        echo 'Usage: exports <exactly-one-beam-file>' >&2
        return 1
    fi
    local dir="$(dirname "$1")"
    local mod="$(basename "$1" .beam)"
    local scr="M = $mod,"
    scr+=' X = lists:sort(M:module_info(exports)'
    scr+=' -- [{module_info, 0}, {module_info, 1}]),'
    scr+=' F = fun({N, A}) -> io:format("    ~s/~b,~n", [N, A]) end,'
    scr+=' lists:foreach(F, X), erlang:halt().'
    erl -noshell -pa "$dir" -eval "$scr"
}

alias we='whence erl'
alias unkerl='kerl_deactivate'
alias rclean='/bin/rm -rf ebin _build .rebar .rebar3 .eunit rebar.lock'

declare -a env_otp_acts
if [[ -d "$LOCAL_OTP_DIR" ]]
then
    declare -a otp_ga
    last_ga=''
    for n in $LOCAL_OTP_DIR/otp-[1-9][0-9]
    do
        a="$n/activate"
        [[ -L "$n" && -f "$a" ]] || continue
        c=${n##*-}
        alias "r$c=. $a"
        env_otp_acts+=($c)
        r="$(readlink $n)"
        if [[ "$r" == "${n##*/}-ga" || "$r" == "${n}-ga" ]]
        then
            last_ga=$c
            otp_ga+=($c)
        fi
    done
    if [[ -n "$last_ga" ]]
    then
        c=${#otp_ga[@]}
        [[ $c -le 3 ]] || otp_ga=($(cut -d ' ' -f $(($c - 2))- <<<"${otp_ga[*]}"))
        alias rtha="rthv ${otp_ga[*]}"
        alias rthax="rthv ${otp_ga[*]} $(($last_ga + 1))"
    fi
    unset a c r last_ga otp_ga
fi


_shrc_cmd_files()
{
    if [[ -n "$LOCAL_ENV_DIR" ]]
    then
        __scf_le="${LOCAL_ENV_DIR%/*}"
        __scf_wd="$(pwd)"
        if [[ "$__scf_wd/" == "$__scf_le/"* ]]
        then
            /bin/ls $__scf_le/home/shrc \
                $__scf_le/root/usr/local/etc/sh.* \
                $__scf_le/root/$(uname -s \
                    | tr '[A-Z]' '[a-z]')/usr/local/etc/sh.* \
                2>/dev/null
            unset __scf_le __scf_wd
            return 0
        fi
        unset __scf_le __scf_wd
    fi
    /bin/ls $HOME/.shrc /usr/local/etc/sh.* 2>/dev/null || true
}
shrc_cmd_names()
{
    __scn_re='s/^[[:space:]]*(alias[[:space:]]+([[:alnum:]_-]+)=.*|([[:alnum:]][[:alnum:]_]*)\(\)[[:space:]]*)$/\2\3/p'
    if [[ $# -gt 0 ]]
    then
        cat "$@" | $ESED -n "$__scn_re" | sort -u
    else
        cat $(_shrc_cmd_files) | $ESED -n "$__scn_re" | sort -u
    fi
    unset __scn_re
}
shrc_cmds()
{
    printf "    printf \"\$env_ss_format\" '%s' ''\\n" $(shrc_cmd_names "$@")
}
shrc_missing()
{
    if [[ $# -gt 0 ]]
    then
        __sm_fl="$*"
    else
        __sm_fl="$(_shrc_cmd_files)"
    fi
    __sm_pf="    printf \"\$env_ss_format\" '%s' ''\\n"
    S='[:space:]'
    for __sm_cn in $(shrc_cmd_names $__sm_fl)
    do
        if ! $EGREP -q \
            "^[$S]+printf[$S]+\"\\\$env_ss_format\"[$S]+'$__sm_cn'[$S]+" \
            $__sm_fl
        then
            printf "$__sm_pf" "$__sm_cn"
        fi
    done
    unset __sm_fl __sm_pf S
}
shrc_longest()
{
    __sl_ln=0
    __sl_lc=''
    for __sl_cn in $(shrc_cmd_names "$@")
    do
        __sl_cl="${#__sl_cn}"
        if [[ $__sl_cl -gt $__sl_ln ]]
        then
            __sl_ln=$__sl_cl
            __sl_lc="$__sl_cn"
        fi
    done
    printf "longest command '%s': %u\\n" "$__sl_lc" $__sl_ln
    unset __sl_cl __sl_cn __sl_lc __sl_ln
}

# s/ss format
env_ss_format_format="    %%-%us %%s\\\\n"
env_ss_length_default=15
env_ss_format_default="$(printf "$env_ss_format_format" $env_ss_length_default)"
env_ss_format="$env_ss_format_default"

ss()
{
    printf "$env_ss_format" 'aws-scp' 'scp with aws identity'
    printf "$env_ss_format" 'aws-ssh' 'ssh with aws identity & rmate port'
    printf "$env_ss_format" 'chimera' 'ssh to chimera with rmate port'
    printf "$env_ss_format" 'tshome' 'ssh to tshome with rmate port'
    printf "$env_ss_format" 'scp' 'scp -p'
    echo ''
    printf "$env_ss_format" 'm' '[r]mate -m ...'
    echo ''
    if [[ ${#env_otp_acts[@]} -gt 0 ]]
    then
        for n in "${env_otp_acts[@]}"
        do
            printf "$env_ss_format" "r$n" "activate Erlang/OTP $n"
        done
    fi
    printf "$env_ss_format" 'we' 'whence erl'
    printf "$env_ss_format" 'unkerl' 'kerl_deactivate'
    printf "$env_ss_format" 'rclean' 'delete rebar2/3 artifacts in the current directory'
    printf "$env_ss_format" 'rth' 'run all steps in the local .travis.yml file with the current environment'
    printf "$env_ss_format" 'rthv' '<Version> ...  run all steps in the local .travis.yml file with OTP-Version(s)'
    [[ "$(typeof rtha)" != 'alias' ]] || \
        printf "$env_ss_format" 'rtha' 'run all steps in the local .travis.yml file with current OTP GAs'
    [[ "$(typeof rthax)" != 'alias' ]] || \
        printf "$env_ss_format" 'rthax' 'run all steps in the local .travis.yml file with current OTP GAs + RC'
    printf "$env_ss_format" 'exports' '<beam-file>  list export statements'
    echo ''
    printf "$env_ss_format" 'chdir' 'same as cd'
    printf "$env_ss_format" 'copyright' '[path] [prefix|style]  write a copyright header to stdout'
    printf "$env_ss_format" 'd2utcs' '<DateTime>  parse default time string to UTC seconds'
    printf "$env_ss_format" 'df' 'df -h'
    printf "$env_ss_format" 'dircp' 'copy directory with pax'
    printf "$env_ss_format" 'dirpath' 'echo the fully-qualified directory name of the argument'
    [[ "$(typeof dscl)" == 'undefined' ]] || \
        printf "$env_ss_format" 'dscl' 'dscl -raw .'
    printf "$env_ss_format" 'ecp' 'cp -p without EAs'
    printf "$env_ss_format" 'egrep' 'grep with EREs'
    printf "$env_ss_format" 'esed' 'sed with EREs'
    printf "$env_ss_format" 'fhoa' '<name> [<highest-dir>]  locate $name in pwd up to highest/$HOME'
    if [[ "$(typeof ideadirs)" != 'undefined' ]]
    then
        printf "$env_ss_format" 'ideadirs' 'list idea project and preferences directories'
        printf "$env_ss_format" 'ideaerls' 'edit idea Erlang (JDK) table'
    fi
    printf "$env_ss_format" 'isvar' 'is argument an environment variable'
    [[ "$(typeof lchflags)" == 'undefined' ]] || \
        printf "$env_ss_format" 'lchflags' 'chflags -h'
    printf "$env_ss_format" 'ldd' 'list dynamic lib dependencies'
    printf "$env_ss_format" 'newbash' '<path>  create a bash executable script'
    printf "$env_ss_format" 'newes' '<path>  create an escript executable script'
    printf "$env_ss_format" 'newksh' '<path>  create a ksh executable script'
    printf "$env_ss_format" 'newscr' '<interpretter> <path>  create an executable script'
    printf "$env_ss_format" 'newsh' '<path>  create a sh executable script'
    printf "$env_ss_format" 'newzsh' '<path>  create a zsh executable script'
    [[ "$(typeof pldump)" == 'undefined' ]] || \
        printf "$env_ss_format" 'pldump' '<path>  dump plist file as xml'
    printf "$env_ss_format" 'remake' 'make clean && make'
    printf "$env_ss_format" 'rp' 'ruby tutorial'
    printf "$env_ss_format" 'rtconf' 'edit riak_test config'
    printf "$env_ss_format" 'th' 'set HISTFILE to disposable temp file'
    printf "$env_ss_format" 'typeof' 'type of command argument is interpretted as'
    [[ "$(typeof unhide)" == 'undefined' ]] || \
        printf "$env_ss_format" 'unhide' 'chflags -h nohidden'
    printf "$env_ss_format" 'utcs' 'print current time as UTC seconds'
    printf "$env_ss_format" 'utcs2d' '<UtcSecs>  print default time string'
    [[ "$(typeof wget)" != 'alias' ]] || \
        printf "$env_ss_format" 'wget' 'curl --remote-name-all'
    printf "$env_ss_format" 'whence' 'ksh-like whence'
    printf "$env_ss_format" 'whereis' 'find all instances of command'
    echo ''
    printf "$env_ss_format" 'cdl' 'cd && lenv'
    printf "$env_ss_format" 'lel' 'List Exported Local environment variables'
    printf "$env_ss_format" 'lenm' 'display loaded custom environment name or path'
    printf "$env_ss_format" 'lenv' '[re]load custom environment for current or parent directory'
    printf "$env_ss_format" 'reset_lenv' 'unload current custom environment'
    printf "$env_ss_format" 'sss' 'display environment maintenance commands'
    printf "$env_ss_format" 'ss' 'display global environment commands'
    [[ "$(typeof s)" == 'undefined' ]] || \
        printf "$env_ss_format" 's' 'display custom environment commands'
    echo ''
}

sss()
{
    if [[ "$(typeof le)" != 'undefined' ]]
    then
        printf "$env_ss_format" 'le' 'cd local environment base directory'
    fi
    printf "$env_ss_format" 'shrc_cmd_names' '[files ...]  list all environment command names'
    printf "$env_ss_format" 'shrc_cmds' '[files ...]  list all potential s/ss entries'
    printf "$env_ss_format" 'shrc_longest' '[files ...]  calculate longest environment command name length'
    printf "$env_ss_format" 'shrc_missing' '[files ...]  list missing s/ss entries'
    printf "$env_ss_format" 'shconf' 'edit shell rc'
    printf "$env_ss_format" 'shrc' 'reload shell rc'
}

unset n
