#!/usr/bin/false This file is meant to be sourced
# ========================================================================
# Copyright (c) 1994-2016 T. R. Burghart.
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# ========================================================================
#
# .shrc - Shell startup script for Bourne-ish login shells
#
# Refer to files in https://github.com/tburghart/local_env
#
# Install to $HOME/.shrc, or wherever $ENV points to
#

#
# file permissions: rwxr-xr-x
#
umask	022
#
# shell specific
#
u="${LOGNAME:-${USER:-$(id -un)}}@$(hostname | cut -d. -f1)"
if [ -n "$KSH_VERSION" ]
then
    set -o vi
    PS1="K \$(date '+%H:%M:%S') $u \$PWD rc:\$?
"
    if [[ $(id -u) -eq 0 ]]
    then
        PS1="${PS1}# "
    else
        PS1="${PS1}\$ "
    fi
	alias which='whence'
    typeof()
    {
        if [[ $# -ne 1 ]]
        then
            echo 'usage: typeof <name>' >&2
            return 1
        fi
        t="$(whence -v "$1" 2>/dev/null)"
        case "$t" in
            *\ tracked\ alias\ * )
                echo file
                ;;
            *\ alias\ * )
                echo alias
                ;;
            *\ builtin )
                echo builtin
                ;;
            *\ function )
                echo function
                ;;
            *\ keyword )
                echo keyword
                ;;
            '' )
                echo undefined
                ;;
            * )
                echo file
                ;;
        esac
        unset t
    }

elif [ -n "$ZSH_VERSION" ]
then
    set -o append_history
    set -o hist_ignore_all_dups
    set -o hist_reduce_blanks
    set -o hist_save_no_dups
    set -o inc_append_history
    set -o vi
    bindkey -v
    bindkey -M vicmd 'k' vi-up-line-or-history
    bindkey -M vicmd 'j' vi-down-line-or-history
    PS1="Z %D{%H:%M:%S} $u %d rc:%?
%(!.#.\$) "
    typeof()
    {
        if [[ $# -ne 1 ]]
        then
            echo 'usage: typeof <name>' >&2
            return 1
        fi
        t="$(whence -v "$1")"
        case "$t" in
            *\ not\ found )
                echo undefined
                ;;
            *\ alias\ * )
                echo alias
                ;;
            *\ builtin )
                echo builtin
                ;;
            *\ function )
                echo function
                ;;
            *\ reserved\ word )
                echo keyword
                ;;
            * )
                echo file
                ;;
        esac
        unset t
    }

elif [ -n "$BASH_VERSION" ]
then
    set -o vi
    PS1="B \\t $u \$PWD rc:\$?\\n\\$ "
    alias whence='type -p'
    alias which='type -p'
    typeof()
    {
        if [[ $# -ne 1 ]]
        then
            echo 'usage: typeof <name>' >&2
            return 1
        fi
        t="$(type -t "$1")"
        if [[ -z "$t" ]]
        then
            echo undefined
        else
            echo "$t"
        fi
        unset t
    }

else    # assume some Bourne variant
    set -o vi
    PS1="s $u \$PWD rc:\$?
"
    if [ $(id -u) -eq 0 ]
    then
        PS1="${PS1}# "
    else
        PS1="${PS1}\$ "
    fi
    typeof()
    {
        if [ $# -ne 1 ]
        then
            echo 'usage: typeof <name>' >&2
            return 1
        fi
        t="$(type "$1" 2>/dev/null 1| head -1)"
        case "$t" in
            '' )
                echo undefined
                ;;
            *\ aliased\ * )
                echo alias
                ;;
            *\ builtin )
                echo builtin
                ;;
            *\ function )
                echo function
                ;;
            *\ reserved\ word )
                echo keyword
                ;;
            * )
                echo file
                ;;
        esac
        unset t
    }
fi
unset   u
export  PS1

if [ "$(typeof chdir)" = 'undefined' ]
then
    chdir()
    {
        command cd "$@"
    }
fi

find_here_or_above()
{
    if [[ $# -lt 1 ]]
    then
        echo 'usage: find_here_or_above <filename> [<highest-dir>]' >&2
        return 1
    fi
    if [[ -n "$2" ]]
    then
        if [[ ! -d "$2" ]]
        then
            echo "error: find_here_or_above: '$2' is not a directory"
            return 1
        fi
        t="$(cd "$2" && pwd)"
    else
        t="$HOME"
    fi
    c="$(pwd)"
    if [[ "$c" != "$t" && "${c#${t}/}" == "$c" ]]
    then
        unset c t
        return 2
    fi
    while true
    do
        if [[ -f "$c/$1" ]]
        then
            echo "$c/$1"
            unset c t
            return 0
        fi
        if [[ "$c" = "$t" ]]
        then
            break
        fi
        c="${c%/*}"
    done
    unset c t
    return 2
}

isvar()
{
    if [[ $# -ne 1 ]]
    then
        echo 'usage: isvar <name>' >&2
        return 1
    fi
    case "$(eval echo "\$$1")" in
        \$ | '' )
            if set | grep -q "^$1="
            then
                return 0
            else
                return 1
            fi
            ;;
        * )
            return 0
            ;;
    esac
}

[[ -n "$lenv_file" ]] || readonly lenv_file='env'

lenm()
{
    if [[ -n "$lenv_label" ]]
    then
        echo $lenv_label
    elif [[ -n "$lenv_current" ]]
    then
        basename "$lenv_current"
    fi
}

# s/ss format
env_ss_format_default='    %-11s %s\n'
env_ss_format="$env_ss_format_default"

lenv()
{
    lenv_target="$(pwd)"
    case "$(typeof reset_lenv)" in
        undefined )
            if [[ -n "$reset_lenv" ]]
            then
                $reset_lenv
                unset reset_lenv
            fi
            ;;
        file )
            . reset_lenv
            ;;
        alias )
            reset_lenv
            unalias reset_lenv 2>/dev/null || true
            ;;
        function )
            reset_lenv
            unset -f reset_lenv 2>/dev/null || true
            ;;
        * )
            reset_lenv
            ;;
    esac
    if [[ -n "$lenv_aliases" ]]
    then
        unalias $lenv_aliases 2>/dev/null
        unset lenv_aliases
    fi
    if [[ -n "$lenv_envvars" ]]
    then
        unset $lenv_envvars 2>/dev/null
        unset lenv_envvars
    fi
    env_ss_format="$env_ss_format_default"

    if [[ -f "$lenv_target/$lenv_file" ]]
    then
        . "$lenv_target/$lenv_file"
        lenv_result=$?
        unset $env_local_unset env_local_unset \
            $(set | $ESED -n 's/^(local_[[:alnum:]_]+)=.*$/\1/p' | tr '\n' ' ')
        if [[ $lenv_result -ne 0 && "$(typeof reset_lenv)" != undefined ]]
        then
            reset_lenv
        fi
        lenv_current="$lenv_target"
        if [[ "$(typeof reset_lenv)" == undefined && -z "$reset_lenv" ]]
        then
            reset_lenv()
            {
                [[ "$(typeof kerl_deactivate)" == 'undefined' ]] || kerl_deactivate

                if [[ -n "$env_reset_path" ]]
                then
                    PATH="$env_reset_path"
                    unset env_reset_path
                    export PATH
                    hash -r
                fi
                if [[ -n "$env_reset_unalias" ]]
                then
                    unalias $env_reset_unalias 2>/dev/null
                    unset env_reset_unalias
                fi
                if [[ -n "$env_reset_unsetf" ]]
                then
                    unset -f $env_reset_unsetf 2>/dev/null
                    unset env_reset_unsetf
                fi
                if [[ -n "$env_reset_unset" ]]
                then
                    unset $env_reset_unset 2>/dev/null
                    unset env_reset_unset
                fi
                env_ss_format="$env_ss_format_default"
                unset -f reset_lenv
            }
        fi
        if [[ $lenv_result -ne 0 ]]
        then
            reset_lenv
            unset lenv_current
        fi
        unset lenv_result
    else
        unset lenv_current 2>/dev/null
    fi
    unset lenv_target
}

cdl()
{
    chdir "$@" || return $?
    lenv
}

newscr()
{
    u='usage: newscr interpretter target-file'
    if [[ $# -ne 2 ]]
    then
        echo "$u" >&2
        unset u
        return 1
    fi
    e=''
    s="$(/usr/bin/which "$1")"
    if [[ -z "$s" ]]
    then
        e="interpretter '$1' not found"
    else
        if [[ -e "$2" ]]
        then
            e="'$2' already exists!"
        else
            e="$(/usr/bin/touch "$2" 2>&1)"
            if [[ -z "$e" ]]
            then
                case "${s##*/}" in
                    escript )
                        printf '#!/usr/bin/env escript\n' > "$2"
                        printf '%% -*- erlang -*-\n' >> "$2"
                        printf '%%! -smp enable +K true -sname %s\n' "${2##*/}" >> "$2"
                        ;;
                    bash | ksh | sh | zsh )
                        printf '#!%s -e -x\n\n' "$s" > "$2"
                        printf 'readonly  sdir="$(cd "$(dirname "$0")" && pwd)"\n' >> "$2"
                        printf 'readonly  sname="${0##*/}"\n' >> "$2"
                        printf 'readonly  spath="$sdir/$sname"\n' >> "$2"
                        ;;
                    * )
                        printf '#!%s\n' "$s" > "$2"
                        ;;
                esac
                printf '\n\n' >> "$2"
                /bin/chmod +x "$2"
            fi
        fi
    fi 
    if [[ -n "$e" ]]
    then
        echo "error: newscr: $e" >&2
        echo "$u" >&2
        unset e s u
        return 1
    fi
    unset e s u
}

giga()
{
    d="$(pwd)"
    if [[ "$d" = "$HOME" ]]
    then
        "$MATE" ~/.gitignore_global
    else
        if [[ "$d" != "${d#${HOME}/}" ]]
        then
            while [[ "$d" != "$HOME" ]]
            do
                if [[ -f "$d/.gitignore" ]]
                then
                    "$MATE" -m "$(basename "$d") .gitignore" "$d/.gitignore"
                    unset d
                    return 0
                fi
                d="${d%/*}"
            done
            "$MATE" ~/.gitignore_global
        fi
    fi
    unset d
}

dirpath()
{
    if [[ $# -ne 1 ]]
    then
        echo 'usage: dirpath <filesystem-path>' >&2
        return 1
    fi
    if [[ -d "$1" ]]
    then
        d="$1"
    else
        d="$(dirname "$1")"
    fi
    case "$d" in
        '.' )
            pwd
            ;;
        '..' )
            dirname "$(pwd)"
            ;;
        * )
            (cd "$d" && pwd)
            ;;
    esac
    unset d
}

m()
{
    if [[ $# -eq 0 ]]
    then
        "$MATE"
    else
        for n in "$@"
        do
            "$MATE" -m "$(basename "$(dirpath "$n")") $(basename "$n")" "$n"
        done
        unset n
    fi
}

# SSH
alias aws-scp='/usr/bin/scp -p -i /Users/ted/.aws/aws.ssh.1.pem'
alias aws-ssh='/usr/bin/ssh -R 52698:localhost:52698 -i /Users/ted/.aws/aws.ssh.1.pem'
alias chimera='/usr/bin/ssh -R 52698:localhost:52698 -l root chimera'
alias gramma='/usr/bin/ssh -R 52698:localhost:52698 -l root -p 22032 gramma'
alias tshome='/usr/bin/ssh -R 52698:localhost:52698 -p 22007 tshome'

# Stuff
alias remake="$MAKE clean && $MAKE"
alias dircp='/bin/pax -rw -pe -X'
alias rtconf="m ~/.riak_test.config"
alias shconf="m ~/.shrc"
alias shrc=". ~/.shrc"
alias b="cd $BASHO_PRJ_BASE"
alias e="$MATE"
alias ideaerls="m ~/Library/Preferences/IdeaIC14/options/jdk.table.xml"
alias ideadirs="/usr/bin/find ~/prj -type d -name .idea && echo ~/Library/Preferences/IdeaIC14/options/jdk.table.xml"
alias t="cd $TRB_PRJ_BASE"

# Dates
alias utcs="date '+%s'"
# BSD and GNU versions of 'date' use different options, try both
d2utcs()
{
    date -jf '%a %b %d %T %Z %Y' "$*" '+%s' 2>/dev/null \
    || date "--date=$*" '+%s'
}
utcs2d()
{
    date -jf '%s' "$*" 2>/dev/null \
    || date "--date=@$*"
}

# Scripts
alias newbash='newscr bash'
alias newes='newscr escript'
alias newksh='newscr ksh'
alias newsh='newscr sh'
alias newzsh='newscr zsh'

# Ruby Path to Enlightenment
alias rp="cd $HOME/prj/ruby/koans && ruby path_to_enlightenment.rb"

# git
alias g="$GIT"
alias ga="$GIT add"
alias gaa="$GIT add -A"
alias gb="$GIT branch"
alias gci="$GIT commit"
alias gcl="$GIT clone"
alias gco="$GIT checkout"
alias gd="$GIT diff"
alias gds="$GIT describe"
alias gigg="m $HOME/.gitignore_global"
alias gl="$GIT log"
alias glr="$GIT log -n 2"
alias gpull="$GIT pull"
alias gpush="$GIT push"
alias gr="$GIT remote"
alias gs="$GIT status"
alias gt="$GIT tag"

gscrub()
{
    local arg
    for arg in "$@"
    do
        case "$arg" in
            -h|--help)
                echo 'Usage: gscrub [-ifnq] [-e <pattern>]' >&2
                echo 'Scrubs the current git repository without mercy!' >&2
                echo "Parameters are passed to 'git clean' unmodified" >&2
                echo "Note that '-f' is already included, adding it a second time will wipe lower-level repos (deps)" >&2
                return 1
            ;;
        esac
    done
    if [[ ! -d '.git' ]]
    then
        echo "gscrub: error: not at the top of a git repo" >&2
        return 2
    fi
    unset REPLY
    printf 'Are you SURE you want to remove all untracked files under\n\t%s?\n' "$(pwd)"
    while read -p '[y/n]: '
    do
        case "$REPLY" in
            [yY]|[yY][eE][sS])
                break
                ;;
            [nN]|[nN][oO])
                return 0
                echo 'when you change your mind, use:'
                echo "$GIT clean -fdqx -e /env -e /env.local -e /.idea/ -e '*.iml' -e '/*.txt'"
                ;;
        esac
    done
    $GIT clean -fdqx -e /env -e /env.local -e /.idea/ -e '*.iml' -e '/*.txt' "$@"
}

gti()
{
    if [[ $# -ne 1 ]]
    then
        echo 'Usage: gti <exactly-one-tag>' >&2
        return 1
    fi
    local ref
    local ret
    local tmp
    ref="$($GIT rev-parse "$1")"
    ret=$?
    if [[ $ret -eq 0 ]]
    then
        tmp="$(mktemp '/tmp/gt.XXXXXXX')"
        $GIT cat-file -p "$ref" >> "$tmp"
        ref="$(awk '/^tagger[[:space:]]/ {print $(NF-1), $(NF)}' "$tmp")"
        # BSD and GNU versions of 'date' use different options, try both
        ref="$(date -jf '%s' "${ref%% *}" '+%Y-%m-%d %H:%M:%S' 2>/dev/null \
            || date "--date=@${ref%% *}" '+%Y-%m-%d %H:%M:%S') ${ref##* }"
        printf '%s\t%s\n' "$1" "$ref"
        cat "$tmp"
        rm "$tmp"
    fi
    return $ret
}

gy()
{
    if [[ $# -ne 1 ]]
    then
        echo 'Usage: gy <exactly-one-file-path>' >&2
        return 1
    fi
    $GIT log --no-decorate -- "$1" \
    | $ESED -n 's/^Date:.* ([12][9012][0-9][0-9]) .*$/\1/p' \
    | /usr/bin/sort -u
}

# Erlang
alias r15=". $LOCAL_OTP_DIR/otp-15/activate"
alias r16=". $LOCAL_OTP_DIR/otp-16/activate"
alias r17=". $LOCAL_OTP_DIR/otp-17/activate"
alias r18=". $LOCAL_OTP_DIR/otp-18/activate"
alias unkerl='kerl_deactivate'
alias we='whence erl'

#
# get this list with:
#
#   cat ~/.shrc /usr/local/etc/sh.* | $ESED -n "s/^[[:space:]]*(alias[[:space:]]+([[:alnum:]_-]+)=.*|([[:alnum:]_]+)\\(\\)[[:space:]]*)\$/    echo '    \\2\\3 '/p" | sort -u
#
# or just the missing ones:
#
#   cat ~/.shrc /usr/local/etc/sh.* | $ESED -n "s/^[[:space:]]*(alias[[:space:]]+([[:alnum:]_-]+)=.*|([[:alnum:]_]+)\\(\\)[[:space:]]*)\$/\\2\\3/p" | sort -u | while read n ; do egrep -q "^[[:space:]]+echo[[:space:]]+'[[:space:]]*$n[[:space:]]" ~/.shrc || echo "    echo '    $n '" ; done
#
ss()
{
    printf "$env_ss_format" 'aws-scp' 'scp with aws identity'
    printf "$env_ss_format" 'aws-ssh' 'ssh with aws identity & rmate port'
    printf "$env_ss_format" 'chimera' 'ssh to chimera with rmate port'
    printf "$env_ss_format" 'gramma' 'ssh to gramma with rmate port'
    printf "$env_ss_format" 'tshome' 'ssh to tshome with rmate port'
    printf "$env_ss_format" 'scp' 'scp -p'
    echo ''
    printf "$env_ss_format" 'la' 'ls -lhA'
    printf "$env_ss_format" 'lat' 'ls -lhAtr'
    printf "$env_ss_format" 'lh' 'ls -lhH'
    printf "$env_ss_format" 'll' 'ls -lh'
    printf "$env_ss_format" 'lld' 'ls -lhd'
    printf "$env_ss_format" 'lll' 'ls -lho@'
    printf "$env_ss_format" 'lr' 'ls -lhR'
    printf "$env_ss_format" 'lt' 'ls -lhtr'
    echo ''
    printf "$env_ss_format" 'g' 'git'
    printf "$env_ss_format" 'ga' 'git add'
    printf "$env_ss_format" 'gaa' 'git add -A'
    printf "$env_ss_format" 'gb' 'git branch'
    printf "$env_ss_format" 'gci' 'git commit'
    printf "$env_ss_format" 'gcl' 'git clone'
    printf "$env_ss_format" 'gco' 'git checkout'
    printf "$env_ss_format" 'gd' 'git diff'
    printf "$env_ss_format" 'gds' 'git describe'
    printf "$env_ss_format" 'giga' 'edit active gitignore'
    printf "$env_ss_format" 'gigg' 'edit global gitignore'
    printf "$env_ss_format" 'gl' 'git log'
    printf "$env_ss_format" 'glr' 'git log recent'
    printf "$env_ss_format" 'gpull' 'git pull'
    printf "$env_ss_format" 'gpush' 'git push'
    printf "$env_ss_format" 'gr' 'git remote'
    printf "$env_ss_format" 'gs' 'git status'
    printf "$env_ss_format" 'gscrub' 'scrub the current git repository without mercy!'
    printf "$env_ss_format" 'gt' 'git tag'
    printf "$env_ss_format" 'gti' '<tag>  list info about one tag'
    printf "$env_ss_format" 'gy' '<path>  list commit years of one file'
    echo ''
    printf "$env_ss_format" 'b' 'cd ~/prj/basho'
    printf "$env_ss_format" 't' 'cd ~/prj/tedb'
    printf "$env_ss_format" 'e' 'edit'
    printf "$env_ss_format" 'm' 'mate -m ...'
    echo ''
    printf "$env_ss_format" 'r15' 'activate erlang R15..basho-current'
    printf "$env_ss_format" 'r16' 'activate erlang R16..basho-current'
    printf "$env_ss_format" 'r17' 'activate erlang OTP-17..basho-current'
    printf "$env_ss_format" 'r18' 'activate erlang OTP-18..basho-current'
    printf "$env_ss_format" 'we' 'whence erl'
    printf "$env_ss_format" 'unkerl' 'kerl_deactivate'
    echo ''
    printf "$env_ss_format" 'chdir' 'same as cd'
    printf "$env_ss_format" 'd2utcs' '<DateTime>  parse default time string to UTC seconds'
    printf "$env_ss_format" 'df' 'df -h'
    printf "$env_ss_format" 'dircp' 'copy directory with pax'
    printf "$env_ss_format" 'dirpath' 'echo the fully-qualified directory name of the argument'
    printf "$env_ss_format" 'dscl' 'dscl -raw .'
    printf "$env_ss_format" 'ideadirs' 'list idea project and preferences directories'
    printf "$env_ss_format" 'ideaerls' 'edit idea Erlang (JDK) table'
    printf "$env_ss_format" 'isvar' 'is argument an environment variable'
    printf "$env_ss_format" 'lchflags' 'chflags -h'
    printf "$env_ss_format" 'ldd' 'list dynamic lib dependencies'
    printf "$env_ss_format" 'newbash' '<path>  create a bash executable script'
    printf "$env_ss_format" 'newes' '<path>  create an escript executable script'
    printf "$env_ss_format" 'newksh' '<path>  create a ksh executable script'
    printf "$env_ss_format" 'newscr' '<interpretter> <path>  create an executable script'
    printf "$env_ss_format" 'newsh' '<path>  create a sh executable script'
    printf "$env_ss_format" 'newzsh' '<path>  create a zsh executable script'
    printf "$env_ss_format" 'pldump' '<path>  dump plist file as xml'
    printf "$env_ss_format" 'remake' 'make clean && make'
    printf "$env_ss_format" 'rp' 'ruby tutorial'
    printf "$env_ss_format" 'rtconf' 'edit riak_test config'
    printf "$env_ss_format" 'typeof' 'type of command argument is interpretted as'
    printf "$env_ss_format" 'unhide' 'chflags -h nohidden'
    printf "$env_ss_format" 'utcs' 'print current time as UTC seconds'
    printf "$env_ss_format" 'utcs2d' '<UtcSecs>  print default time string'
    printf "$env_ss_format" 'whence' 'ksh-like whence'
    printf "$env_ss_format" 'whereis' 'find all instances of command'
    echo ''
    printf "$env_ss_format" 'cdl' 'cd && lenv'
    printf "$env_ss_format" 'lenv' '[re]load custom environment for current or parent directory'
    printf "$env_ss_format" 'shconf' 'edit shell rc'
    printf "$env_ss_format" 'shrc' 'reload shell rc'
    printf "$env_ss_format" 'ss' 'display this list'
    echo ''
}
